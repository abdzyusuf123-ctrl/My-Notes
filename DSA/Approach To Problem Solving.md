# Introduction to Problem Solving

---
## ğŸš€ Most Important Information

**Core Logic** 
- Most Coding Interview questions will have a core logic (in a form of a for or while loop) that will do some computation over and over again until the desired output of a test case is met
- The path to finding what that core logic is based on finding which **algorithm** to use

**Memory** 
- Most Coding Interview questions will also require you to keep track of some data (for instance tracking the maximum sum) which is then updated and reused by the core logic to help us get the desired output
- The path to finding which kind of memery to use is based on finding which **Data Structure** to use

  
Before starting **any technical interview problem**, follow these key steps to ensure a clear, structured approach.

---

## ğŸ§  Understand the Problem

1. **Cut unnecessary information** â€” focus only on the relevant parts of the problem.  
2. **Rephrase or rewrite** the problem in your own words to ensure full understanding.  
3. **Confirm the inputs and outputs** â€” clearly define whatâ€™s given and whatâ€™s expected.  

ğŸ’¡ *Goal:* You should be able to explain the problem to someone else in one or two sentences.

---

## ğŸ“¸ Create a Snapshot

Once you understand the problem, document it clearly.

1. **Write down the example test case** (or create one if not provided).  
2. **Write down the expected output** for that test case.  
3. **Describe the computation** needed to get from input â†’ output.  
4. **List edge cases** to watch out for (empty input, single element, large values, etc.).  

ğŸ’¡ *This snapshot acts as your problem blueprint.*

---

## ğŸ” Identify the Pattern

Now that you know what the problem asks and how to get the output:

1. Start with a **brute-force solution** â€” solve it the simple way first.  
2. Then, look for a **pattern or optimization** that speeds up the process.  

ğŸ’¡ *Most DSA problems are pattern-based â€” recognizing them is key to efficiency.*

---

## ğŸ§© Design a Plan

Once the pattern is clear:

1. **Choose the data structure or algorithm** (and any variant).  
2. **List all variables** required (e.g., counters, min/max, temp storage, etc.).  
3. **Define conditions** that must be met at each iteration or recursion step.  

ğŸ’¡ *This is your game plan â€” think through it before touching any code.*

---

## âœï¸ Write Pseudocode

Now translate your plan into simple, readable pseudocode.

1. Write the design using plain-language code structure.  
2. Simulate test cases **step by step** to verify that it produces the expected result.  

ğŸ’¡ *If your pseudocode works logically, implementation becomes mechanical.*

---

> ğŸ’­ *Think first. Code second. Optimize last.*
